---
- name: Install PostgreSQL Stack (PostgreSQL 17 + PostgREST + pgweb + Authelia)
  hosts: all
  become: true
  vars:
    # Hardcoded paths
    install_dir: "/opt/pgstack"
    data_dir: "/opt/pgstack/data"
    project_name: "pgstack"

    # Hardcoded service paths
    pgweb_path: "/pgweb"
    postgrest_path: "/postgrest"
    auth_path: "/auth"
    authelia_path: "/authelia"

    # Hardcoded ports (internal only)
    postgres_port: 5432
    postgrest_port: 3000
    pgweb_port: 8081
    authelia_port: 9091
    auth_port: 5000

    # Hardcoded database settings
    postgres_db: "postgres"
    postgres_user: "postgres"
    postgrest_role: "authenticator"
    postgrest_anon_role: "anon"

    # SSL is always enabled
    enable_ssl: true

  tasks:
    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - domain is defined
          - domain | length > 0
          - admin_email is defined
          - admin_email | length > 0
          - authelia_admin_password is defined
          - authelia_admin_password | length >= 8
        fail_msg: "Required variables: domain, admin_email, authelia_admin_password (min 8 chars)"

    # Set defaults for optional username variables
    - name: Set default API user name
      ansible.builtin.set_fact:
        api_user_name: "{{ api_user_name | default('api_user') }}"

    - name: Set default API admin name
      ansible.builtin.set_fact:
        api_admin_name: "{{ api_admin_name | default('api_admin') }}"

    # Generate all passwords automatically
    - name: Generate PostgreSQL password
      ansible.builtin.set_fact:
        postgres_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"

    - name: Generate PostgREST authenticator password
      ansible.builtin.set_fact:
        postgrest_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"

    - name: Generate PostgREST JWT secret
      ansible.builtin.set_fact:
        postgrest_jwt_secret: "{{ lookup('password', '/dev/null length=64 chars=ascii_letters,digits') }}"

    - name: Generate Authelia JWT secret
      ansible.builtin.set_fact:
        authelia_jwt_secret: "{{ lookup('password', '/dev/null length=64 chars=ascii_letters,digits') }}"

    - name: Generate Authelia session secret
      ansible.builtin.set_fact:
        authelia_session_secret: "{{ lookup('password', '/dev/null length=64 chars=ascii_letters,digits') }}"

    - name: Generate Authelia storage encryption key
      ansible.builtin.set_fact:
        authelia_storage_encryption_key: "{{ lookup('password', '/dev/null length=64 chars=ascii_letters,digits') }}"

    - name: Generate API user password
      ansible.builtin.set_fact:
        api_user_password: "{{ lookup('password', '/dev/null length=24 chars=ascii_letters,digits') }}"

    - name: Generate API admin password
      ansible.builtin.set_fact:
        api_admin_password: "{{ lookup('password', '/dev/null length=24 chars=ascii_letters,digits') }}"

    # Nginx Detection
    - name: Check if system Nginx is installed
      ansible.builtin.command: which nginx
      register: nginx_binary
      failed_when: false
      changed_when: false

    - name: Check if ports 80 and 443 are in use
      ansible.builtin.shell: |
        set -o pipefail
        port80=$(ss -tuln | grep ':80 ' || echo "free")
        port443=$(ss -tuln | grep ':443 ' || echo "free")
        if [[ "$port80" != "free" ]] || [[ "$port443" != "free" ]]; then
          echo "in_use"
        else
          echo "free"
        fi
      register: ports_check
      changed_when: false

    - name: Fail if ports are occupied and Nginx is not installed
      ansible.builtin.fail:
        msg: |
          ERROR: Ports 80 and/or 443 are already in use, but Nginx is not installed.
          Options:
          1. Free up ports 80/443 and re-run
          2. Install Nginx manually first
      when:
        - nginx_binary.rc != 0
        - ports_check.stdout == 'in_use'

    - name: Display deployment info
      ansible.builtin.debug:
        msg:
          - "Installing PostgreSQL Stack to {{ install_dir }}"
          - "Domain: {{ domain }}"
          - "SSL: Enabled (Certbot)"

    # Install dependencies
    - name: Install required packages
      ansible.builtin.package:
        name:
          - curl
          - ca-certificates
          - gnupg
          - openssl
        state: present

    - name: Check if Docker is installed
      ansible.builtin.command: docker --version
      register: docker_installed
      failed_when: false
      changed_when: false

    - name: Install Docker (Debian/Ubuntu)
      block:
        - name: Add Docker GPG key
          ansible.builtin.apt_key:
            url: https://download.docker.com/linux/{{ ansible_distribution | lower }}/gpg
            state: present

        - name: Add Docker repository
          ansible.builtin.apt_repository:
            repo: "deb [arch={{ 'amd64' if ansible_architecture == 'x86_64' else 'arm64' }}] https://download.docker.com/linux/{{ ansible_distribution | lower }} {{ ansible_distribution_release }} stable"
            state: present

        - name: Install Docker packages
          ansible.builtin.apt:
            name:
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-compose-plugin
            state: present
            update_cache: true
      when:
        - docker_installed.rc != 0
        - ansible_os_family == "Debian"

    - name: Install Docker (RHEL/CentOS/Rocky/Alma)
      block:
        - name: Add Docker repository
          ansible.builtin.yum_repository:
            name: docker-ce
            description: Docker CE Stable
            baseurl: "https://download.docker.com/linux/{{ 'centos' if ansible_distribution == 'CentOS' else 'rhel' if ansible_distribution in ['RedHat', 'OracleLinux'] else ansible_distribution | lower }}/{{ ansible_distribution_major_version }}/$basearch/stable"
            gpgcheck: true
            gpgkey: "https://download.docker.com/linux/{{ 'centos' if ansible_distribution == 'CentOS' else 'rhel' if ansible_distribution in ['RedHat', 'OracleLinux'] else ansible_distribution | lower }}/gpg"
            enabled: true

        - name: Install Docker packages
          ansible.builtin.dnf:
            name:
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-compose-plugin
            state: present
      when:
        - docker_installed.rc != 0
        - ansible_os_family == "RedHat"

    - name: Start and enable Docker service
      ansible.builtin.systemd:
        name: docker
        state: started
        enabled: true

    - name: Hash Authelia admin password
      ansible.builtin.shell: docker run --rm authelia/authelia:4.38.16 authelia crypto hash generate argon2 --password "{{ authelia_admin_password }}" | grep 'Digest:' | awk '{print $2}'
      register: authelia_password_hash_result
      changed_when: false

    - name: Set Authelia admin password hash
      ansible.builtin.set_fact:
        authelia_admin_password_hash: "{{ authelia_password_hash_result.stdout }}"

    - name: Create installation directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ install_dir }}"
        - "{{ data_dir }}"
        - "{{ data_dir }}/postgres"
        - "{{ data_dir }}/authelia"

    # Create configuration files
    - name: Create .env file
      ansible.builtin.template:
        src: templates/env.j2
        dest: "{{ install_dir }}/.env"
        mode: '0600'

    - name: Create compose.yml
      ansible.builtin.template:
        src: templates/compose.yml.j2
        dest: "{{ install_dir }}/compose.yml"
        mode: '0644'

    - name: Create PostgREST configuration
      ansible.builtin.template:
        src: templates/postgrest.conf.j2
        dest: "{{ install_dir }}/postgrest.conf"
        mode: '0644'

    - name: Create Authelia configuration
      ansible.builtin.template:
        src: templates/authelia-config.yml.j2
        dest: "{{ install_dir }}/authelia-config.yml"
        mode: '0600'

    - name: Create Authelia users database
      ansible.builtin.template:
        src: templates/authelia-users.yml.j2
        dest: "{{ install_dir }}/authelia-users.yml"
        mode: '0600'

    - name: Create PostgreSQL init script
      ansible.builtin.template:
        src: templates/init-postgrest.sql.j2
        dest: "{{ install_dir }}/init-postgrest.sql"
        mode: '0644'

    - name: Create Auth service Python script
      ansible.builtin.template:
        src: templates/auth-service.py.j2
        dest: "{{ install_dir }}/auth-service.py"
        mode: '0755'

    - name: Create Auth service requirements file
      ansible.builtin.template:
        src: templates/auth-requirements.txt.j2
        dest: "{{ install_dir }}/auth-requirements.txt"
        mode: '0644'

    - name: Create Auth service Dockerfile
      ansible.builtin.template:
        src: templates/Dockerfile.auth.j2
        dest: "{{ install_dir }}/Dockerfile.auth"
        mode: '0644'

    # Install and configure Nginx
    - name: Check if system Nginx is already installed
      ansible.builtin.command: which nginx
      register: system_nginx_check
      failed_when: false
      changed_when: false

    - name: Install Nginx (Debian/Ubuntu)
      ansible.builtin.apt:
        name: nginx
        state: present
        update_cache: true
      when:
        - system_nginx_check.rc != 0
        - ansible_os_family == "Debian"

    - name: Install Nginx (RHEL/CentOS/Rocky/Alma)
      ansible.builtin.dnf:
        name: nginx
        state: present
      when:
        - system_nginx_check.rc != 0
        - ansible_os_family == "RedHat"

    - name: Start and enable Nginx service
      ansible.builtin.systemd:
        name: nginx
        state: started
        enabled: true

    # Create initial HTTP config for Certbot validation
    - name: Create initial Nginx configuration for Certbot (Debian/Ubuntu)
      ansible.builtin.copy:
        dest: "/etc/nginx/sites-available/{{ project_name }}"
        mode: '0644'
        content: |
          server {
              listen 80;
              listen [::]:80;
              server_name {{ domain }};

              location /.well-known/acme-challenge/ {
                  root /var/www/html;
              }

              location / {
                  return 301 https://$host$request_uri;
              }
          }
      when: ansible_os_family == "Debian"

    - name: Create initial Nginx configuration for Certbot (RHEL)
      ansible.builtin.copy:
        dest: "/etc/nginx/conf.d/{{ project_name }}.conf"
        mode: '0644'
        content: |
          server {
              listen 80;
              listen [::]:80;
              server_name {{ domain }};

              location /.well-known/acme-challenge/ {
                  root /var/www/html;
              }

              location / {
                  return 301 https://$host$request_uri;
              }
          }
      when: ansible_os_family == "RedHat"

    - name: Enable Nginx site (Debian/Ubuntu)
      ansible.builtin.file:
        src: "/etc/nginx/sites-available/{{ project_name }}"
        dest: "/etc/nginx/sites-enabled/{{ project_name }}"
        state: link
      when: ansible_os_family == "Debian"

    - name: Test Nginx configuration
      ansible.builtin.command: nginx -t
      changed_when: false

    - name: Reload Nginx
      ansible.builtin.systemd:
        name: nginx
        state: reloaded

    # Start Docker services
    - name: Pull Docker images
      ansible.builtin.command: docker compose pull
      args:
        chdir: "{{ install_dir }}"
      register: docker_pull
      changed_when: "'Downloaded' in docker_pull.stderr or 'Pulled' in docker_pull.stderr"

    - name: Check for existing containers
      ansible.builtin.shell: |
        set -o pipefail
        docker ps -a --format '{{ '{{' }}.Names{{ '}}' }}' | grep -E '^{{ project_name }}-' || true
      register: existing_containers
      changed_when: false

    - name: Fail if containers already exist
      ansible.builtin.fail:
        msg: |
          ERROR: Existing containers detected for project '{{ project_name }}'.
          Run uninstall.yml first or manually remove containers:
            docker rm -f $(docker ps -a --filter name={{ project_name }} -q)
      when: existing_containers.stdout != ''

    - name: Start PostgreSQL Stack services
      ansible.builtin.command: docker compose up -d
      args:
        chdir: "{{ install_dir }}"
      register: docker_up
      changed_when: "'Started' in docker_up.stderr or 'Created' in docker_up.stderr"

    - name: Wait for PostgreSQL to be ready
      ansible.builtin.shell: docker exec {{ project_name }}-db pg_isready -U {{ postgres_user }}
      changed_when: false
      register: result
      until: result.rc == 0
      retries: 30
      delay: 5

    - name: Initialize PostgREST roles in database
      ansible.builtin.shell: docker exec -i {{ project_name }}-db psql -U {{ postgres_user }} -d {{ postgres_db }} < {{ install_dir }}/init-postgrest.sql
      register: init_result
      changed_when: "'CREATE ROLE' in init_result.stdout"

    - name: Wait for PostgREST to be ready
      ansible.builtin.uri:
        url: "http://localhost:{{ postgrest_port }}"
        status_code: 200
      register: result
      until: result.status == 200
      retries: 30
      delay: 5

    - name: Wait for pgweb to be ready
      ansible.builtin.uri:
        url: "http://localhost:{{ pgweb_port }}"
        status_code: 200
      register: result
      until: result.status == 200
      retries: 30
      delay: 5

    - name: Wait for Authelia to be ready
      ansible.builtin.uri:
        url: "http://localhost:{{ authelia_port }}/api/health"
        status_code: 200
      register: result
      until: result.status == 200
      retries: 30
      delay: 5

    # Pre-generate TOTP for admin user (bypasses email verification)
    - name: Generate TOTP secret for admin user
      ansible.builtin.shell: |
        docker exec {{ project_name }}-authelia authelia storage user totp generate \
          --config /config/configuration.yml \
          "{{ admin_email }}" 2>&1
      register: totp_generate_result
      changed_when: true
      failed_when: false

    - name: Extract TOTP secret from output
      ansible.builtin.set_fact:
        totp_secret: "{{ totp_generate_result.stdout | regex_search('Secret:\\s+([A-Z2-7]+)', '\\1') | first | default('') }}"
      when: totp_generate_result.stdout is defined

    - name: Wait for Auth service to be ready
      ansible.builtin.uri:
        url: "http://localhost:{{ auth_port }}/health"
        status_code: 200
      register: result
      until: result.status == 200
      retries: 30
      delay: 5

    # SSL with Certbot
    - name: Install Certbot (Debian/Ubuntu)
      ansible.builtin.apt:
        name:
          - certbot
          - python3-certbot-nginx
        state: present
      when: ansible_os_family == "Debian"

    - name: Install Certbot (RHEL/Rocky/Alma)
      ansible.builtin.dnf:
        name:
          - certbot
          - python3-certbot-nginx
        state: present
      when: ansible_os_family == "RedHat"

    - name: Obtain SSL certificate
      ansible.builtin.command: >
        certbot --nginx
        -d {{ domain }}
        --non-interactive
        --agree-tos
        --email {{ admin_email }}
        --redirect
      register: certbot_result
      changed_when: "'Successfully received certificate' in certbot_result.stdout"

    - name: Apply HTTPS Nginx configuration (Debian/Ubuntu)
      ansible.builtin.template:
        src: templates/nginx-https-postgresql-stack.conf.j2
        dest: "/etc/nginx/sites-available/{{ project_name }}"
        mode: '0644'
      when: ansible_os_family == "Debian"

    - name: Apply HTTPS Nginx configuration (RHEL)
      ansible.builtin.template:
        src: templates/nginx-https-postgresql-stack.conf.j2
        dest: "/etc/nginx/conf.d/{{ project_name }}.conf"
        mode: '0644'
      when: ansible_os_family == "RedHat"

    - name: Test and reload Nginx
      ansible.builtin.shell: nginx -t && systemctl reload nginx

    - name: Setup automatic certificate renewal
      ansible.builtin.cron:
        name: "Renew Let's Encrypt certificates"
        minute: "0"
        hour: "0,12"
        job: "certbot renew --quiet --post-hook 'systemctl reload nginx'"

    - name: Display installation summary
      ansible.builtin.debug:
        msg:
          - "============================================"
          - "PostgreSQL Stack Installation Complete!"
          - "============================================"
          - ""
          - "Base URL: https://{{ domain }}"
          - ""
          - "Services:"
          - "  pgweb:     https://{{ domain }}/pgweb/"
          - "  PostgREST: https://{{ domain }}/postgrest/"
          - "  Auth:      https://{{ domain }}/auth/"
          - "  Authelia:  https://{{ domain }}/authelia/"
          - ""
          - "PostgreSQL:"
          - "  User: {{ postgres_user }}"
          - "  Password: {{ postgres_password }}"
          - "  Database: {{ postgres_db }}"
          - ""
          - "API Credentials:"
          - "  {{ api_user_name }} / {{ api_user_password }}"
          - "  {{ api_admin_name }} / {{ api_admin_password }}"
          - ""
          - "Authelia (2FA for pgweb):"
          - "  Username: {{ admin_email }}"
          - "  Password: {{ authelia_admin_password }}"
          - "  TOTP Secret: {{ totp_secret | default('Not generated') }}"
          - ""
          - "TOTP Setup (Google Authenticator):"
          - "  1. Open Google Authenticator (or Authy, etc.)"
          - "  2. Tap '+' > 'Enter a setup key'"
          - "  3. Account name: {{ admin_email }}"
          - "  4. Your key: {{ totp_secret | default('See above') }}"
          - "  5. Key type: Time-based (default)"
          - "  6. Tap 'Add'"
          - ""
          - "SAVE THESE CREDENTIALS!"
          - ""
          - "Installation: {{ install_dir }}"
          - "============================================"

  handlers:
    - name: Reload Nginx
      ansible.builtin.systemd:
        name: nginx
        state: reloaded
